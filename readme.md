
# 3D Action Game Framework (OpenGL & Custom Library)

<img src="_image/OpenGL_3d.png" width="450px" height="300px" title="플레이 스크린샷" alt=" ">

## 프로젝트 개요

상용 엔진을 사용하지 않고, OpenGL 기반의 커스텀 라이브러리(`gslib2015`)를 활용하여 밑바닥부터 구축한 3D 액션 게임 프레임워크입니다. 엔진의 내부 동작 원리를 이해하고, C++을 이용한 객체 지향 설계 역량을 쌓는 것을 목표로 진행한 프로젝트입니다.


## 개발 스택

* **Language:** C++
* **Graphics API:** OpenGL (커스텀 라이브러리 gslib2015)

## 주요 설계, 구현 특징

### 1. 계층 구조 기반의 액터 시스템

모든 게임 객체를 `Actor`로 추상화하고, 부모-자식 관계를 가질 수 있는 트리 구조로 설계했습니다.

* **장점:** `World`에서 루트 노드의 `update()`와 `draw()`를 한 번 호출하는 것만으로 전체 객체 트리를 순회하며 갱신할 수 있어 관리가 용이합니다.
* **단점:** 트리가 깊어질 경우 순회 비용이 발생할 수 있으나, 본 프로젝트에서는 `ActorGroup`을 통해 논리적으로 레이어를 분리하여 관리 효율을 높였습니다.

### 2. 효율적인 객체관리와 충돌 처리

`ActorManager`를 통해 객체들을 그룹별(`Player`, `Enemy`, `Bullet` 등)로 관리하고, 필요한 그룹 간의 충돌만 명시적으로 수행하도록 설계했습니다.

* **최적화:** 모든 객체 간의 충돌을 확인하지 않고, `Player` vs `Enemy`, `PlayerBullet` vs `Enemy` 등 유의미한 관계만 정의하여 연산량을 최적화했습니다.
* **물리연산:** `BoundingSphere`를 활용한 구체 충돌 판정을 기본으로 하며, 지형과의 상호작용은 `Ray`를 활용한 지형 높이 보정 로직을 적용했습니다.

### 3. 상태 머신 (FSM) 기반 캐릭터 로직

캐릭터의 상태(`Move`, `Attack`, `Damage`, `GetUp`)를 상태 머신으로 관리하여 액션 로직을 가독성 있게 구현했습니다.

* 각 상태는 `stateTimer_`와 애니메이션 종료 시점을 기준으로 동기화하여 로직의 꼬임을 방지하였습니다.
* 상태별로 분리된 로직은 이슈 발생 시 이슈 캐치에 용이하며 새로운 액션을 추가할때 기존코드에 미치는 영향을 최소화 하였습니다.

### 4. 메시지 기반 객체 간 결합도 낮춤

`World`와 `Actor` 사이에 `EventMessage` 시스템을 구축하여 객체 간 직접적인 참조를 지양했습니다.

* 예를 들어, 플레이어가 대미지를 입었을 때 특정 객체를 직접 수정하는 대신 메시지를 송신하는 방식을 취해 코드 간 의존성을 낮췄습니다.


---
